# -*- coding: utf-8 -*-
"""knn_Alexandra_Chuvatin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Kijw_i7t-eG3sHSQ4BzSCoaC2OCkIyWe
"""

import pandas as pd
import numpy as np
from sklearn.metrics import confusion_matrix
from sklearn.utils import shuffle
import matplotlib.pyplot as plt
import math

"""
LECTURE DES FICHIERS
"""
def ReadFile(filename):
  df=pd.read_csv(filename,sep=",",header=None)
  dimension=()
  dimension=df.shape
  nb_var=dimension[1]
  nb_indiv=dimension[0]
  var=[]
  for i in range(0,nb_var):
    var.append(df.iloc[:,i])
    
  I=[]
  Itemp=[]
    
  for i in range(0,nb_indiv):
    for v in var:
      Itemp.append(v[i]) 
    I.append(Itemp)
    Itemp=[]

  return I

"""
REPARTITION EN DONNEES D'APPRENTISSAGE ET D'EVALUATION
"""
def Repartition(data):
  data=shuffle(data)
  part=math.floor(0.8*len(data))
  train=data[:part]
  test=data[part:]
  return train, test

"""
CALCUL DISTANCE EUCLIDIENNE
"""
def Distance(i1,i2):
  dist=0
  for index in range(0,len(i1)-2):
    dist+=(float(i1[index])-float(i2[index]))**2
  return np.sqrt(float(dist))

"""
K PLUS PROCHES VOISINS
"""
def KPlusProche(train, k, test):
  train=sorted(train, key=lambda x: Distance(test, x))
  #Les k plus proches voisins
  top=[]
  for i in range(k):
    top.append(train[i])
  #les classes des k plus proches voisins
  labels=[]
  for i in top:
    labels.append(i[len(i)-1])
  #récuperer la classe qui apparaît le plus souvent    
  cpt=0 #compte le nombre d'apparition de la classe
  index=0 #index de l'individu qui a la classe qui appraît le plus souvent
  for i in range(len(labels)):
    if labels.count(labels[i]) > cpt:
      cpt = labels.count(labels[i])
      index=i
  return labels[index]

"""
TAUX DE REUSSITE
"""
def Exact(prediction, realite):
  cpt=0
  for i in range(len(prediction)):
    if realite[i] == prediction[i]:
      cpt+=1
  cpt=cpt*100/(len(realite)-1)
  return cpt

"""
MATRICE DE CONFUSION
"""
def Confusion(realite,prediction, classes):
  fig,ax=plt.subplots(1,1)
  matrice=confusion_matrix(realite, prediction)

  for i in range(len(matrice)):
    for j in range(len(matrice)):
      plt.text(j,i,round(matrice[i][j],1),ha="center",va="center")
  ax.set_xticklabels(classes)
  ax.set_yticklabels(classes)
  plt.imshow(matrice, cmap='Purples')
  plt.title("Matrice de confusion")

"""
GRAPHIQUE : TAUX DE REUSSITE EN FONCTION DE K
"""
def Reussite_fct_K(realite):
  P=[]
  prediction=[]
  for k in range(1,10):
    #print("k =",k)
    for i in range(len(realite)):
      prediction.append(KPlusProche(train, k, test[i]))
    P.append(Exact(prediction,realite))
    #print(Exact(prediction,realite),"%","\n")
    prediction=[]
  K=range(1,10)
  plt.plot(K,P,"r*-")
  plt.title("Taux de réussite en fonction de k")
  plt.xlabel("-- k --")
  plt.ylabel("Taux de réussite")
  plt.show()
  

def Resultats(prediction):
  prediction="\n".join(prediction)
  with open("chuvatin.txt","w") as f:
    f.write(prediction)
  f.close()


if __name__ == "__main__":
  
  #LECTURE DU FICHIER
  I=ReadFile("preTest.csv")
  Itest=ReadFile("finalTest.csv")

  #REPARTITION EN DONNEES DE TRAIN ET TEST
  #train, test = Repartition(I)
  train=I
  test=Itest

  #CLASSES POSSIBLES (utilisé pour la matrice de confusion)
  classes=set() #dans un set car on ne veut pas de répetitions
  classes.add("")
  for i in I:
    classes.add(i[len(i)-1])
  classes=sorted(classes)

  
  #CLASSES ATTENDUES (utilisé pour la matrice de confusion)
  realite=[]
  for i in range(len(test)):
    realite.append(test[i][6])
  
  #GRAPHIQUE : % DE REUSSITE EN FONCTION DE K 
  Reussite_fct_K(realite)
  

  #PREDICTION DES CLASSES
  prediction=[]
  for i in range(len(test)):
    prediction.append(KPlusProche(train, 4, test[i]))

  Resultats(prediction)

  
  #MATRICE DE CONFUSION (POUR K = 4)
  Confusion(realite,prediction,classes)
  
  
  """
  #VERIFICATION FORMAT FICHIER SORTIE
  allLabels = ['classA','classB','classC','classD','classE']
  #ce fichier s'attend à lire 3000 prédictions, une par ligne
  #réduisez nbLines en période de test.
  nbLines = 3000
  fd =open("chuvatin.txt",'r')
  lines = fd.readlines()

  count=0
  for label in lines:
	  if label.strip() in allLabels:
		  count+=1
	  else:
		  if count<nbLines:
			  print("Wrong label line:"+str(count+1))
			  break
  if count<nbLines:
	  print("Labels Check : fail!")
  else:
  	print("Labels Check : Successfull!")
  """